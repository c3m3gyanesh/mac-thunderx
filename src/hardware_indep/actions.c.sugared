from p4_hlir.hlir.p4_headers import p4_field, p4_field_list
from p4_hlir.hlir.p4_imperatives import p4_signature_ref
from utils import *

from header_info import hdr_prefix, fld_prefix
def fld_id(f): return fld_prefix(f.instance.name + "_" + f.name)

#[ #include "odp_lib.h"
#[ #include "actions.h"
#[ #include <unistd.h>
#[ #include <arpa/inet.h>

actions = hlir.p4_actions
useractions = userActions(actions)
useraction_objs = [(actions[act_key]) for act_key in useractions ]

def modify_field(fun, call):
    generated_code = ""
    args = call[1]
    dst = args[0]
    src = args[1]
    # mask = args[2]
    if not isinstance(dst, p4_field):
        addError("generating modify_field", "We do not allow changing an R-REF yet")
    if isinstance(src, int):
        #[ value32 = ${src};
        if dst.width <= 32:
            if not dst.instance.metadata:
                #[ value32 = htonl(value32);
            #[ MODIFY_INT32_INT32(pkt, ${fld_id(dst)}, value32)
        else:
            if dst.width % 8 == 0 and dst.offset % 8 == 0:
                #[ MODIFY_BYTEBUF_INT32(pkt, ${fld_id(dst)}, value32)
            else:
                addError("generating modify_field", "Improper bytebufs cannot be modified yet.")
    elif isinstance(src, p4_field):
        if dst.width <= 32 and src.length <= 32:
            #[ EXTRACT_INT32(pkt, ${fld_id(src)}, value32)
            if not src.instance.metadata:
                #[ value32 = ntohl(value32);
            #[ MODIFY_INT32_INT32(pkt, ${fld_id(dst)}, value32)
        elif src.width != dst.width:
            addError("generating modify_field", "bytebuf field-to-field of different widths is not supported yet")
        else:
            if dst.width % 8 == 0 and dst.offset % 8 == 0 and src.width % 8 == 0 and src.offset % 8 == 0 and src.instance.metadata == dst.instance.metadata:
                #[ MODIFY_BYTEBUF_BYTEBUF(pkt, ${fld_id(dst)}, FIELD_BYTE_ADDR(pkt, field_desc(${fld_id(src)})), (field_desc(${fld_id(dst)})).bytewidth)
            else:
                addError("generating modify_field", "Improper bytebufs cannot be modified yet.")
    elif isinstance(src, p4_signature_ref):
        p = "parameters.%s" % str(fun.signature[src.idx])
        l = fun.signature_widths[src.idx]
        if dst.width <= 32 and l <= 32:
            if not dst.instance.metadata:
                #[ value32 = htonl(value32);
            #[ MODIFY_INT32_BYTEBUF(pkt, ${fld_id(dst)}, ${p}, ${(l+7)/8})
        else:
            if dst.width % 8 == 0 and dst.offset % 8 == 0 and l % 8 == 0: #and dst.instance.metadata:
                #[ MODIFY_BYTEBUF_BYTEBUF(pkt, ${fld_id(dst)}, ${p}, (field_desc(${fld_id(dst)})).bytewidth)
            else:
                addError("generating modify_field", "Improper bytebufs cannot be modified yet.")        
    return generated_code

def add_to_field(fun, call):
    generated_code = ""
    args = call[1]
    dst = args[0]
    val = args[1]
    if not isinstance(dst, p4_field):
        addError("generating add_to_field", "We do not allow changing an R-REF yet")
    if isinstance(val, int):
        #[ value32 = ${val};
        if dst.width <= 32:
            #[ EXTRACT_INT32(pkt, ${fld_id(dst)}, res32)
            if not dst.instance.metadata:
                #[ res32 = ntohl(res32);
            #[ value32 += res32;
            if not dst.instance.metadata:
                #[ value32 = htonl(value32);
            #[ MODIFY_INT32_INT32(pkt, ${fld_id(dst)}, value32)
        else:
            addError("generating modify_field", "Bytebufs cannot be modified yet.")
    elif isinstance(val, p4_field):
        if dst.width <= 32 and val.length <= 32:
            #[ EXTRACT_INT32(pkt, ${fld_id(val)}, value32)
            #[ EXTRACT_INT32(pkt, ${fld_id(dst)}, res32)
            #[ value32 += res32;
            if not val.instance.metadata:
                #[ value32 = ntohl(value32);
            #[ MODIFY_INT32_INT32(pkt, ${fld_id(dst)}, value32)
        else:
            addError("generating add_to_field", "bytebufs cannot be modified yet.")
    elif isinstance(val, p4_signature_ref):
        p = "parameters.%s" % str(fun.signature[val.idx])
        l = fun.signature_widths[val.idx]
        if dst.width <= 32 and l <= 32:
            if not dst.instance.metadata:
                #[ value32 = htonl(value32);
            #[ EXTRACT_INT32(pkt, ${fld_id(dst)}, res32)
            #[ TODO
        else:
            addError("generating add_to_field", "bytebufs cannot be modified yet.")
    return generated_code

def create_generate_digest(call, fun_params, fun):
    generated_code = ""
    
    ## TODO make this proper
    fun_params += ["\"mac_learn_digest\""]
    for p in call[1]:
        if isinstance(p, int):
            fun_params += "0" #[str(p)]
        elif isinstance(p, p4_field_list):
            field_list = p
            fun_params += ["&fields"]
        else:
            addError("generating actions.c", "Unhandled parameter type in generate_digest: " + str(p))
 
    #[  struct type_field_list fields;
    quan = str(len(field_list.fields))
    #[    fields.fields_quantity = ${quan};
    #[    fields.field_offsets = malloc(sizeof(uint8_t*)*fields.fields_quantity);
    #[    fields.field_widths = malloc(sizeof(uint8_t*)*fields.fields_quantity);
    for i,field in enumerate(field_list.fields):
        j = str(i)
        if isinstance(field, p4_field):
            #[    fields.field_offsets[${j}] = (uint8_t*) (pkt->headers[header_instance_${field.instance}].pointer + field_instance_byte_offset_hdr[field_instance_${field.instance}_${field.name}]);
            #[    fields.field_widths[${j}] = field_instance_bit_width[field_instance_${field.instance}_${field.name}]*8;
        else:
            addError("generating actions.c", "Unhandled parameter type in field_list: " + name + ", " + str(field))

    params = ",".join(fun_params)
    #[
    #[    generate_digest(${params}); sleep(1);
    return generated_code

def create_drop(call, fun_params, fun):
    params = ",".join(fun_params)
    val = "drop(%s);" % params
    return val

#[ extern backend bg;
#[


for fun in useraction_objs:
    hasParam = fun.signature
    modifiers = ""
    ret_val_type = "void"
    name = fun.name
    params = ", struct action_%s_params parameters" % (name) if hasParam else ""
    #[ ${modifiers} ${ret_val_type} action_code_${name}(packet_descriptor_t* pkt, lookup_table_t** tables ${params}) {
    #[     uint32_t value32, res32;
    #[     (void)value32;
    #[     (void)res32;
    for i,call in enumerate(fun.call_sequence):
        # NOTE: called functions require the packet as the first argument
        fun_params = ["pkt"]
        if call[0].name == "modify_field":
            #[ ${modify_field(fun, call)}
        elif call[0].name == "add_to_field":
            #[ ${add_to_field(fun, call)}
        elif call[0].name == "generate_digest":
            fun_params = ["bg"]
            generated_code += create_generate_digest(call, fun_params, fun);
        elif call[0].name == "drop":
            code = create_drop(call, fun_params, fun)
            #[ ${code}
        else:
            addWarning("generating actions.c", "Unhandled primitive function: " +  call[0].name)     
            
    #[ }
    #[

